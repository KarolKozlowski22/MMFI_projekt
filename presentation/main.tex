\documentclass{beamer}
\usetheme{Warsaw}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{verbatim}

\usepackage[utf8]{inputenc} 
\usepackage[polish]{babel}  
\usepackage[T1]{fontenc}
\usepackage{verbatim}

\title{Zastosowanie metod formalnych}
\author{Karol Kozlowski,}
\institute{Wydzial elektryczny, Politechnika Warszawska}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section{Wprowadzenie do metod formalnych}
\begin{frame}{Czym sa metody formalne?}
\begin{block}{Definicja}
  Metody formalne to techniki matematyczne służące do:
\begin{itemize}
\item Specyfikacji - precyzyjnego opisu systemów za pomocą języków matematycznych (np. logika temporalna, rachunek procesów)
\item Weryfikacji - dowodzenia poprawności systemów poprzez np. model checking (np. narzędzie SPIN) lub dowody twierdzeń (np. Coq, Isabelle)
\item Automatyzacji analizy  wykrywania sprzeczności lub luk w projektach na etapie modelowania (np. weryfikacja protokołów kryptograficznych)
\end{itemize}
Wiecej na ten temat mozna znalezc w \cite{spin_needham_schroeder}.
\end{block}
\end{frame}

\begin{frame}
\begin{exampleblock}{Kluczowe zalety}
\begin{itemize}
\item Formalne gwarancje poprawności - zapewnienie matematycznie udowodnionej poprawności systemów, szczególnie w przypadku wymagań bezpieczeństwa.
\item Precyzyjna specyfikacja wymagań - eliminacja niejednoznaczności dzięki matematycznym modelom i notacjom.
\item Wykrywanie złożonych błędów - identyfikacja problemów takich jak zakleszczenia (deadlocks) czy warunki wyścigu (race conditions), które trudno wykryć tradycyjnymi metodami testowania.
\end{itemize}
Wiecej na ten temat mozna znalezc w \cite{wojnicki2019weryfikacja}.
\end{exampleblock}

\end{frame}

\section{Wykorzystanie metod formalnych w systemie PVS}
\subsection{Wprowadzenie do systemu PVS}
\begin{frame}[fragile]{System PVS w pigułce}
  System PVS służy do opracowania i weryfikacji specyfikacji opisujących
  różne zagadnienia. PVS posiada rozbudowaną składnię i umożliwia operowanie w
  logice wyższego rzędu, definiowanie własnych typów i podtypów danych oraz
  tworzenie teorii parametryzowanych \cite{paper}.

\begin{verbatim}
  pointer_env [P: TYPE, T: TYPE]: THEORY
  BEGIN
    pointer: TYPE = P + {nil}
    env: TYPE = [pointer -> (T + {undefined})]
  END pointer_env
\end{verbatim}
\end{frame}

\subsection{Jaki problem rozwiazuje system PVS?}
\begin{frame}{Problem: Weryfikacja struktur dynamicznych}
\begin{alertblock}{Główne wyzwania}
  \begin{itemize}
  \item \textbf{Złożoność struktur wskaźnikowych}:
  \begin{itemize}
      \item Wycieki pamięci
      \item Nieprawidłowe dereferencje
      \item Zakleszczenia w systemach współbieżnych
  \end{itemize}
  
  \item \textbf{Niejednoznaczność specyfikacji}:
  \begin{itemize}
      \item Niewystarczalność logiki pierwszego rzędu
      \item Potrzeba logiki wyższego rzędu (PVS)
  \end{itemize}
  
  \item \textbf{Krytyczne zastosowania}:
  \begin{itemize}
      \item Systemy sterowania (metro, koleje)
      \item Aplikacje medyczne
      \item Systemy awioniki i kosmiczne
  \end{itemize}
\end{itemize}

Wiecej na ten temat mozna znalezc w \cite{paper}.
\end{alertblock}
\end{frame}

\subsection{Rozwiazanie PVS}
\begin{frame}{Rozwiazanie PVS}

    \begin{itemize}
      \item Formalna specyfikacja niezmienników
      \item Automatyczna weryfikacja warunków spójności
      \item Półautomatyczne dowodzenie poprawności
    \end{itemize}
\end{frame}

\subsection{Formalna specyfikacja niezmiennikow}
\begin{frame}[fragile]{Przyklad}
  \begin{exampleblock}{Przyklad}
    
  \begin{verbatim}
    accessed_disjoint?(accessed? : pred[pointer[P]]) : 
    boolean =
    FORALL(v11,v12 : (valid_finseq_list?)) :
       (accessed?(v11) AND accessed?(v12) AND v11 
       /= v12 =>
        FORALL(1 : pointer[P]) : value?(1) =>
        NOT list_member?(1,v11) OR NOT 
        list_member?(1,v12))
    \end{verbatim}
  \end{exampleblock}

\end{frame}

\subsection{Automatyczna weryfikacja warunkow spójności}

\begin{frame}[fragile]{Przyklad}
  \begin{exampleblock}{TCC1 dla niepustosci listy, TCC2 dla zachowania typu w rekurencji, TCC3 dla warunku stopu rekurencji}
 
    \begin{verbatim}
      last_TCC1: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): NOT empty?(vl)
    \end{verbatim}

    \begin{verbatim}
      last_TCC2: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): 
        length(vl) > 1 IMPLIES valid_finseq_list?(tail(vl))
    \end{verbatim}

    \begin{verbatim}
      last_TCC3: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): 
        length(vl) > 1 IMPLIES length(tail(vl)) < length(vl)
    \end{verbatim}
  \end{exampleblock}
    
\end{frame}

\subsection{Półautomatyczne dowodzenie poprawności}

% \begin{frame}[fragile]{Przykladdd}

% \end{frame}


\subsection{Podsumowanie}
\begin{frame}
\begin{block}{Podsumowanie}
\begin{itemize}
\item Metoda skuteczna dla list i drzew.
\item Wymaga dużego nakładu pracy.
\item Obiecujące wyniki dla systemów krytycznych.
\end{itemize}
\end{block}
\end{frame}

\section{Zastosowanie metod formalnych: TLA+}
\begin{frame}{Czym jest TLA+?}
  \begin{itemize}
      \item TLA+ (Temporal Logic of Actions) - język specyfikacji formalnej opracowany przez Lesliego Lamporta.
      \item Służy do opisu systemów współbieżnych i rozproszonych.
      \item System definiowany jako zbiór zmiennych i akcji - przejść między stanami.
      \item Deklaratywny - skupia się na zachowaniu, nie na implementacji.
      \item Bazuje na logice temporalnej i matematyce zbiorów.
  \end{itemize}
\end{frame}

\begin{frame}{Narzędzie TLC i model checking}
  \begin{itemize}
      \item Weryfikacja poprawności specyfikacji odbywa się z użyciem narzędzia TLC.
      \item TLC używa techniki model checking:
      \begin{itemize}
          \item automatyczne przeszukiwanie przestrzeni stanów,
          \item sprawdzanie właściwości bezpieczeństwa i ciągłości.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Metoda 1: Modelowanie matematyczne (FIFO)}
  \textbf{Fragment specyfikacji bufora w TLA+:}
  \vspace{0.5em}

  \begin{verbatim}
VARIABLE queue

Init == queue = << >>

Enq(x) == queue' = Append(queue, x)

Deq == /\ queue # << >>
       /\ queue' = Tail(queue)
  \end{verbatim}

  \vspace{0.1em}
  \begin{itemize}
    \item Bufor jako lista (\texttt{queue}).
    \item Akcje opisują przejścia między stanami.
  \end{itemize}
\end{frame}

  
  
\begin{frame}[fragile]{Metoda 2: Inwariant bezpieczeństwa}
  \textbf{Fragment definicji inwariantu w TLA+:}
  \vspace{0.5em}

  \begin{verbatim}
TypeInvariant ==
  /\ queue \in Seq(Int)
  /\ Len(queue) >= 0

Inv == TypeInvariant
  \end{verbatim}

  \vspace{0.1em}
  \begin{itemize}
    \item Bufor jest sekwencją liczb całkowitych.
    \item Długość bufora nie może być ujemna.
    \item Inwarianty są sprawdzane automatycznie przez TLC.
    \item Chronią przed błędami, np. usunięciem z pustej kolejki.
  \end{itemize}
\end{frame}



\begin{frame}[fragile]{Metoda 3: Własności temporalne}
  \textbf{Fragment specyfikacji własności temporalnych w TLA+:}
  \vspace{0.5em}

  \begin{verbatim}
Safety == [](Len(queue) >= 0)

Liveness == <>(queue = << >>)
  \end{verbatim}

  \vspace{0.1em}
  \begin{itemize}
    \item \texttt{Safety} (bezpieczeństwo): długość bufora nigdy nie jest ujemna.
    \item \texttt{Liveness} (ciągłość): bufor w końcu się opróżni.
    \item Temporalne właściwości opisują zachowanie w czasie.
  \end{itemize}
\end{frame}

\begin{frame}{Zastosowania TLA+}
  \begin{itemize}
      \item Firmy: Amazon, Microsoft, Google.
      \item Projektowanie i weryfikacja systemów:
      \begin{itemize}
          \item rozproszonych,
          \item bazodanowych,
          \item komunikacyjnych,
          \item chmurowych.
      \end{itemize}
      \item Identyfikacja błędów przed implementacją - kluczowa dla systemów krytycznych.
  \end{itemize}
\end{frame}




\begin{frame}{Bibliografia}
  \scriptsize
  \begin{thebibliography}{9}
  
    \bibitem{lamport2002specifying}
    Leslie Lamport, \emph{Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers}, Addison-Wesley, 2002.
  
    \bibitem{newcombe2015amazon}
    Chris Newcombe et al., \emph{How Amazon Web Services Uses Formal Methods}, Communications of the ACM, 2015.
  
    \bibitem{konnov2019tla}
    Igor Konnov, Jure Kukovec, Thanh-Hai Tran, \emph{TLA+ Model Checking Made Symbolic}, CAV 2019.
  
    \bibitem{wayne2018practical}
    Hillel Wayne, \emph{Practical TLA+: Planning Driven Development}, Lospinato Books, 2018.
    
  \end{thebibliography}
\end{frame}


\end{document}