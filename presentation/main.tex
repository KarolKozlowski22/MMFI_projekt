\documentclass{beamer}
\usetheme{Warsaw}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[utf8]{inputenc} 
\usepackage[polish]{babel}  
\usepackage[T1]{fontenc}
\usepackage{verbatim}

\title{Zastosowanie metod formalnych}
\author{Karol Kozlowski,}
\institute{Wydzial elektryczny, Politechnika Warszawska}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section{Wprowadzenie do metod formalnych}
\begin{frame}{Czym sa metody formalne?}
\begin{block}{Definicja}
  Metody formalne to techniki matematyczne służące do:
\begin{itemize}
\item Specyfikacji - precyzyjnego opisu systemów za pomocą języków matematycznych (np. logika temporalna, rachunek procesów)
\item Weryfikacji - dowodzenia poprawności systemów poprzez np. model checking (np. narzędzie SPIN) lub dowody twierdzeń (np. Coq, Isabelle)
\item Automatyzacji analizy  wykrywania sprzeczności lub luk w projektach na etapie modelowania (np. weryfikacja protokołów kryptograficznych)
\end{itemize}
Wiecej na ten temat mozna znalezc w \cite{spin_needham_schroeder}.
\end{block}
\end{frame}

\begin{frame}
\begin{exampleblock}{Kluczowe zalety}
\begin{itemize}
\item Formalne gwarancje poprawności - zapewnienie matematycznie udowodnionej poprawności systemów, szczególnie w przypadku wymagań bezpieczeństwa.
\item Precyzyjna specyfikacja wymagań - eliminacja niejednoznaczności dzięki matematycznym modelom i notacjom.
\item Wykrywanie złożonych błędów - identyfikacja problemów takich jak zakleszczenia (deadlocks) czy warunki wyścigu (race conditions), które trudno wykryć tradycyjnymi metodami testowania.
\end{itemize}
Wiecej na ten temat mozna znalezc w \cite{wojnicki2019weryfikacja}.
\end{exampleblock}

\end{frame}

\section{Wykorzystanie metod formalnych w systemie PVS}
\subsection{Wprowadzenie do systemu PVS}
\begin{frame}[fragile]{System PVS w pigułce}
  System PVS służy do opracowania i weryfikacji specyfikacji opisujących
  różne zagadnienia. PVS posiada rozbudowaną składnię i umożliwia operowanie w
  logice wyższego rzędu, definiowanie własnych typów i podtypów danych oraz
  tworzenie teorii parametryzowanych \cite{paper}.

\begin{verbatim}
  pointer_env [P: TYPE, T: TYPE]: THEORY
  BEGIN
    pointer: TYPE = P + {nil}
    env: TYPE = [pointer -> (T + {undefined})]
  END pointer_env
\end{verbatim}
\end{frame}

\subsection{Jaki problem rozwiazuje system PVS?}
\begin{frame}{Problem: Weryfikacja struktur dynamicznych}
\begin{alertblock}{Główne wyzwania}
  \begin{itemize}
  \item \textbf{Złożoność struktur wskaźnikowych}:
  \begin{itemize}
      \item Wycieki pamięci
      \item Nieprawidłowe dereferencje
      \item Zakleszczenia w systemach współbieżnych
  \end{itemize}
  
  \item \textbf{Niejednoznaczność specyfikacji}:
  \begin{itemize}
      \item Niewystarczalność logiki pierwszego rzędu
      \item Potrzeba logiki wyższego rzędu (PVS)
  \end{itemize}
  
  \item \textbf{Krytyczne zastosowania}:
  \begin{itemize}
      \item Systemy sterowania (metro, koleje)
      \item Aplikacje medyczne
      \item Systemy awioniki i kosmiczne
  \end{itemize}
\end{itemize}

Wiecej na ten temat mozna znalezc w \cite{paper}.
\end{alertblock}
\end{frame}

\subsection{Rozwiazanie PVS}
\begin{frame}{Rozwiazanie PVS}

    \begin{itemize}
      \item Formalna specyfikacja niezmienników
      \item Automatyczna weryfikacja warunków spójności
      \item Półautomatyczne dowodzenie poprawności
    \end{itemize}
\end{frame}

\subsection{Formalna specyfikacja niezmiennikow}
\begin{frame}[fragile]{Przyklad}
  \begin{exampleblock}{Przyklad}
    
  \begin{verbatim}
    accessed_disjoint?(accessed? : pred[pointer[P]]) : 
    boolean =
    FORALL(v11,v12 : (valid_finseq_list?)) :
       (accessed?(v11) AND accessed?(v12) AND v11 
       /= v12 =>
        FORALL(1 : pointer[P]) : value?(1) =>
        NOT list_member?(1,v11) OR NOT 
        list_member?(1,v12))
    \end{verbatim}
  \end{exampleblock}

\end{frame}

\subsection{Automatyczna weryfikacja warunkow spójności}

\begin{frame}[fragile]{Przyklad}
  \begin{exampleblock}{TCC1 dla niepustosci listy, TCC2 dla zachowania typu w rekurencji, TCC3 dla warunku stopu rekurencji}
 
    \begin{verbatim}
      last_TCC1: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): NOT empty?(vl)
    \end{verbatim}

    \begin{verbatim}
      last_TCC2: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): 
        length(vl) > 1 IMPLIES valid_finseq_list?(tail(vl))
    \end{verbatim}

    \begin{verbatim}
      last_TCC3: OBLIGATION 
      FORALL (vl: (valid_finseq_list?)): 
        length(vl) > 1 IMPLIES length(tail(vl)) < length(vl)
    \end{verbatim}
  \end{exampleblock}
    
\end{frame}

\subsection{Półautomatyczne dowodzenie poprawności}

% \begin{frame}[fragile]{Przykladdd}

% \end{frame}


\subsection{Podsumowanie}
\begin{frame}
\begin{block}{Podsumowanie}
\begin{itemize}
\item Metoda skuteczna dla list i drzew.
\item Wymaga dużego nakładu pracy.
\item Obiecujące wyniki dla systemów krytycznych.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Bibliografia}
  \bibliographystyle{plain} 
  \bibliography{bibliografia} 

\end{frame}

\end{document}